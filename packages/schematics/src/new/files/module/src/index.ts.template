import {
  Game,
  Action,
  Scene,
  Label,
  WebColors,
  RandomDraws,
  GameParameters,
  GameOptions,
  TrialSchema,
  Timer,
  Constants,
  Transition,
  TransitionDirection,
  Easings,  
} from "@m2c2kit/core";
import { Button, CountdownScene, Instructions } from "@m2c2kit/addons";

export class <%= classify(appName) %> extends Game {
  constructor() {
    /**
     * These are configurable game parameters and their defaults.
     * Each game parameter should have a type, default (this is the default
     * value), and a description.
     */
    const defaultParameters: GameParameters = {
      countdown_duration_ms: {
        default: 3000,
        type: "number",
        description:
          "Duration of the countdown phase ('get ready' countdown, milliseconds). Multiples of 1000 recommended.",
      },
      number_of_trials: {
        type: "integer",
        default: 4,
        description: "How many trials to run.",
      },
      percent_even_trials: {
        type: "number",
        default: 0.5,
        description: "What percent of trials should be even numbers?",
      },
      number_range: {
        type: "array",
        default: [1, 10],
        description: "The range of numbers to present, inclusive. This must be an array in the form of [min, max].",
      },
    };

    /**
     * Trial schema describes all the data that will be generated by the
     * assessment in a single trial. Each variable should have a type and
     * description. If a variable might be null, the type can be an array:
     *   type: ["string", "null"]
     * Object and array types are also allowed, but this example uses only
     * simple types.
     *
     * More advanced schema parameters such as format or enum are optional.
     *
     * At runtime, when a trial completes, the data will be returned to the
     * session with a callback, along with this schema transformed into
     * JSON Schema.
     */
    const trialSchema: TrialSchema = {
      activity_uuid: {
        type: "string",
        format: "uuid",
        description: "Unique identifier for all trials in this activity.",
      },
      trial_index: {
        type: ["integer", "null"],
        description: "Index of the trial within this assessment, 0-based.",
      },
      presented_number: {
        type: "number",
        description: "The number that was presented.",
      },
      selection_correct: {
        type: "boolean",
        description: "Was the user's even/odd selection correct?",
      },
      response_time_ms: {
        type: "number",
        description:
          "How long, in milliseconds, from when the number was presented until the user made a selection.",
      },
    };

    const options: GameOptions = {
      name: "<%= appName %>",
      /**
       * This id must match the property m2c2kit.assessmentId in package.json
       */
      id: "<%= dasherize(appName) %>",
      publishUuid: "<%= publishUuid %>",      
      /**
       * Leave the next line as-is, and the insertVersionString() rollup plugin
       * will automatically populate this with the version property listed in
       * the module's package.json. Or, manually edit the version property
       * with a value (not recommended).
       */
      version: "__PACKAGE_JSON_VERSION__",
      /**
       * Leave the next line as-is, and the addModuleMetadata() rollup plugin
       * will automatically populate this with necessary metadata.
       */
      moduleMetadata: Constants.MODULE_METADATA_PLACEHOLDER,
      shortDescription:
        "A simple even/odd assessment created by the m2c2kit CLI.",
      longDescription: `This is a simple even/odd assessment created by the \
m2c2kit CLI. It is a starting point for creating your own assessment modules.`,
      uri: "https://<add a link to your assessment repository or informational website>",
      /**
       * Actual pixel resolution will be scaled to fit the device, while
       * preserving the aspect ratio. It is important, however, to specify
       * a width and height to obtain the desired aspect ratio. In most
       * cases, you should not change this. 1:2 is a good aspect ratio
       * for modern phones.
       */
      width: 400,
      height: 800,
      trialSchema: trialSchema,
      parameters: defaultParameters,
      /**
       * The Roboto-Regular.ttf font is licensed under the Apache License,
       * and its LICENSE.TXT will be copied as part of the build.
       */
      fonts: [
        {
          fontName: "roboto",
          url: "fonts/roboto/Roboto-Regular.ttf",
        },
      ],
      images: [
        {
          imageName: "smiley",
          /**
           * The image will be resized to the height and width specified.
           */
          height: 100,
          width: 100,
          /**
           * The image url must match the location of the image under the
           * assets folder. The below image is public domain, derived from
           * https://commons.wikimedia.org/wiki/File:Face-smile.svg
           */
          url: "images/face-smile.png",
        },
      ],
    };

    // Always end the constructor with a super call to the Game constructor.
    super(options);
  }

  override async initialize() {
    // Always begin the initialize() method with an await super.initialize()
    await super.initialize();
    /**
     * Just for convenience, alias the variable game to "this"
     * (even though eslint doesn't like it)
     */
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const game = this;

    /**
     * ************************************************************************
     * Trial Configuration
     *
     * It is often necessary to create the full trial configuration before
     * starting any trials to fulfill a desired set of parameters. For
     * example, this assessment guarantees the percent of even number trials
     * presented across all trials.
     *
     * The trial configuration should provide everything needed to set up a
     * single trial. In this simple example, a trial configuration is
     * only the presented number, but more complex assessments will have
     * more properties.
     */

    interface TrialConfiguration {
      presented_number: number;
    }

    const trialConfigurations: TrialConfiguration[] = [];

    /**
     * TypeScript will try to infer the type of the game parameter that
     * you request in game.getParameter(). If the type cannot be inferred, you
     * will get a compiler error, and you must specify the type in angle
     * brackets, as seen below.
     */
    const numberOfTrials = game.getParameter<number>("number_of_trials");
    const numberOfEvenTrials = Math.round(
      numberOfTrials * game.getParameter<number>("percent_even_trials")
    );
    const evenTrialIndexes = RandomDraws.FromRangeWithoutReplacement(
      numberOfEvenTrials,
      0,
      numberOfTrials - 1
    );
    const lowerBound = game.getParameter<Array<number>>("number_range")[0];
    const upperBound = game.getParameter<Array<number>>("number_range")[1];
    for (let i = 0; i < numberOfTrials; i++) {
      let number;
      /**
       * If the trial index is in the evenTrialIndexes array, then we
       * present an even number. Otherwise, we present an odd
       * number. We also must ensure that the number is within the range of
       * lowerBound and upperBound. We "loop around" from the upperBound to
       * the lowerBound if the number is out of range when shifting a number
       * to the next even or odd number.
       */
      if (evenTrialIndexes.indexOf(i) !== -1) {
        number = RandomDraws.SingleFromRange(lowerBound, upperBound);
        while (number % 2 === 1 || number > upperBound) {
          if (number > upperBound) {
            number = lowerBound;
            continue;
          }
          number++;
        }
      } else {
        number = RandomDraws.SingleFromRange(lowerBound, upperBound);
        while (number % 2 === 0 || number > upperBound) {
          if (number > upperBound) {
            number = lowerBound;
            continue;
          }
          number++;
        }
      }

      trialConfigurations.push({
        presented_number: number,
      });
    }

    /**
     * ************************************************************************
     * Scenes: Instructions
     */
    const instructionsScenes = Instructions.create({
      instructionScenes: [
        {
          title: "<%= appName %>",
          text: `For this activity, indicate if the presented number is even or odd.`,
          textFontSize: 20,
          titleFontSize: 30,
        },
        {
          title: "<%= appName %>",
          text: `For example, if the number is 7, the correct response is Odd.`,
          textFontSize: 20,
          titleFontSize: 30,
          textVerticalBias: 0.25,
          imageName: "smiley",
          imageAboveText: false,
          imageMarginTop: 20,
          /**
           * Override the next button's default text and color
           */
          nextButtonText: "START",
          nextButtonBackgroundColor: WebColors.Green,
        },
      ],
    });
    /**
     * Instructions.create() returns an array of scenes, so we add them to the
     * game using addScenes() instead of addScene().
     */
    game.addScenes(instructionsScenes);

    /**
     * ************************************************************************
     * Scene: countdown. Show countdown for countdown_duration_ms milliseconds
     */
    const countdownScene = new CountdownScene({
      milliseconds: game.getParameter<number>("countdown_duration_ms"),
      text: "GET READY!",
    });
    game.addScene(countdownScene);

    /**
     * ************************************************************************
     * Scene: Present the word and get user selection
     */
    const presentationScene = new Scene();
    game.addScene(presentationScene);

    /**
     * The "Is the number odd or even?" label and the two buttons will always
     * be displayed in this presentation scene, so we create them in the body
     * of the initialize() method and add them to the game.
     */
    const isNumberOddEvenLabel = new Label({
      text: "Is the number odd or even?",
      fontSize: 24,
      position: { x: 200, y: 100 },
    });
    presentationScene.addChild(isNumberOddEvenLabel);

    const oddButton = new Button({
      text: "Odd",
      size: { width: 150, height: 50 },
      position: { x: 100, y: 700 },
      backgroundColor: WebColors.RoyalBlue,
      isUserInteractionEnabled: true,
    });
    oddButton.onTapDown(() => {
      handleUserSelection(true);
    });
    presentationScene.addChild(oddButton);

    const evenButton = new Button({
      text: "Even",
      size: { width: 150, height: 50 },
      position: { x: 300, y: 700 },
      backgroundColor: WebColors.RoyalBlue,
      isUserInteractionEnabled: true,
    });
    evenButton.onTapDown(() => {
      handleUserSelection(false);
    });
    presentationScene.addChild(evenButton);

    /**
     * There will always be a number presented to the user in this
     * scene, so we create the label here in the body of the initialize()
     * method and add it to the game. But, the number will vary across trials,
     * so we will assign the presented number to the label's text property
     * within the scene's onSetup() callback. For now, assign an empty
     * string to the label's text property.
     */
    const presentedNumberLabel = new Label({
      text: "",
      position: { x: 200, y: 400 },
      fontSize: 64,
    });
    presentationScene.addChild(presentedNumberLabel);

    presentationScene.onSetup(() => {
      const trialConfiguration = trialConfigurations[game.trialIndex];
      /**
       * The presented number will vary across trials. Thus, we assign the
       * presented number, as specific to this trial, to the label within
       * the presentation scene's onSetup() callback. We do this in onSetup()
       * so that the number is assigned before the scene slides into view.
       */
      presentedNumberLabel.text =
        trialConfiguration.presented_number.toString();
    });

    presentationScene.onAppear(() => {
      /**
       * Start the timer in onAppear() because this is when the number
       * is presented to the user and when the user can make a selection.
       */
      Timer.startNew("responseTime");
      /**
       * To avoid double taps after a user selection, we previously set both
       * buttons' isUserInteractionEnabled to false once they made a selection
       * in the previous trial. Here, we set it back to true to allow the user
       * to make a selection again for this trial.
       */
      oddButton.isUserInteractionEnabled = true;
      evenButton.isUserInteractionEnabled = true;
    });

    function handleUserSelection(selectedOdd: boolean): void {
      const trialConfiguration = trialConfigurations[game.trialIndex];
      /**
       * Set both buttons' isUserInteractionEnabled to false to prevent
       * double taps before the next trial starts.
       */
      oddButton.isUserInteractionEnabled = false;
      evenButton.isUserInteractionEnabled = false;

      Timer.stop("responseTime");
      game.addTrialData("response_time_ms", Timer.elapsed("responseTime"));
      Timer.remove("responseTime");
      game.addTrialData(
        "presented_number",
        trialConfiguration.presented_number
      );
      const correct =
        (trialConfiguration.presented_number % 2 === 0 &&
          selectedOdd === false) ||
        (trialConfiguration.presented_number % 2 === 1 && selectedOdd === true);
      game.addTrialData("selection_correct", correct);
      game.addTrialData("trial_index", game.trialIndex);
      game.addTrialData("activity_uuid", game.uuid);
      /**
       * When the trial has completed, we must call game.trialComplete() to
       * 1) Increase the game.trialIndex counter
       * 2) Trigger events that send the trial data to event subscribers
       */
      game.trialComplete();

      // Are we done all the trials, or should we do another trial iteration?
      if (game.trialIndex === numberOfTrials) {
        game.presentScene(doneScene);
      } else {
        game.presentScene(
          presentationScene,
          /**
           * Omit the next argument or replace with Transition.none() if no
           * transition animation is wanted.
           */
          Transition.slide({
            direction: TransitionDirection.Left,
            duration: 500,
            easing: Easings.sinusoidalInOut,
          })
        );
      }
    }

    /**
     * ************************************************************************
     * Scene: Done. Show the done message and exit button.
     */
    const doneScene = new Scene();
    game.addScene(doneScene);

    const doneSceneText = new Label({
      text: "You have completed all the <%= appName %> trials",
      position: { x: 200, y: 400 },
    });
    doneScene.addChild(doneSceneText);

    const okButton = new Button({
      text: "OK",
      position: { x: 200, y: 600 },
      isUserInteractionEnabled: true,
    });
    okButton.onTapDown(() => {
      // Don't allow repeat taps of ok button
      okButton.isUserInteractionEnabled = false;
      /**
       * When the game is done, we must call game.end() to transfer control
       * back to the session runner, which will then start the next activity or
       * send a session end event to the event subscribers.
       */
      game.end();
    });
    doneScene.addChild(okButton);
  }
}
